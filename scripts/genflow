#!/usr/bin/env escript
%%! -pz ../lincx

-include_lib("lincx/priv/ofp_v4.hrl").
-include_lib("lincx/apps/linc_max/include/linc_max.hrl").

main([TabName]) ->
	random:seed(now()),
	FlowTab = list_to_atom(TabName),
	CurDir = filename:dirname(escript:script_name()),
	ConfFile = filename:join(CurDir, "genflow.conf"),
	{ok,Conf} = file:consult(ConfFile),
	case proplists:get_value(FlowTab, Conf) of
	undefined ->
		io:format("Error: ~s has no configuration for ~s\n", [ConfFile,TabName]),
		halt(1);
	TabConf ->
		Flows = generate(TabConf),
		TabFile = filename:join(["priv",TabName ++ ".tab"]),
		{ok,Out} = file:open(TabFile, [write]),
		io:format(Out, "%% autogenerated by ~s\n\n", [escript:script_name()]),
		lists:foreach(fun(F) ->
			io:format(Out, "~p.\n", [F])
		end, Flows),
		file:close(Out),
		io:format("~s generated\n", [TabFile])
	end.

generate(TabConf) ->
	generate(1, 2, TabConf) ++ generate(2, 1, TabConf).

generate(InPort, OutPort, TabConf) ->
	NumFlows = proplists:get_value(num_flows, TabConf, 100),
	Matches = proplists:get_all_values(match, TabConf),
	AllowArp = proplists:get_bool(allow_arp, TabConf),

	[#flow_entry{match =#ofp_match{fields =
							[#ofp_field{name =in_port,value = <<InPort:32>>}]
					++ more_matches(Matches)},instructions =[]}
		|| _ <- lists:seq(1, NumFlows)]
	
		++ if AllowArp ->
			[#flow_entry{match =#ofp_match{fields =
							[#ofp_field{name =in_port,value = <<InPort:32>>},
							 #ofp_field{name =eth_type,value = <<8,6>>}]},
						 instructions =[#ofp_instruction_write_actions{actions =
								[#ofp_action_output{port = <<OutPort:32>>}]}]}];
			true -> [] end

		++ [#flow_entry{match =#ofp_match{fields =
							[#ofp_field{name =in_port,value = <<InPort:32>>}]},
						instructions =[#ofp_instruction_write_actions{actions =
								[#ofp_action_output{port = <<OutPort:32>>}]}]}].

more_matches(Matches) ->
	more_matches(Matches, []).

more_matches([], Acc) ->
	lists:reverse(Acc);
more_matches([{Prob,Fld}|Matches], Acc) ->
	N = bit_len(Fld),
	Val = random:uniform(1 bsl N) -1,
	Spec = #ofp_field{name =Fld,value = <<Val:N>>,has_mask =false},
	more_matches1(Prob, Spec, Matches, Acc);
more_matches([{Prob,Fld,nomask}|Matches], Acc) ->
	N = bit_len(Fld),
	Val = random:uniform(1 bsl N) -1,
	Spec = #ofp_field{name =Fld,value = <<Val:N>>,has_mask =false},
	more_matches1(Prob, Spec, Matches, Acc);
more_matches([{Prob,Fld,Mask}|Matches], Acc) ->
	N = bit_len(Fld),
	Val = random:uniform(1 bsl N) -1,
	Spec = #ofp_field{name =Fld,
					  value = <<(Val band Mask):N>>,
					  has_mask =true,
					  mask = <<Mask:N>>},
	more_matches1(Prob, Spec, Matches, Acc).

more_matches1(Prob, Spec, Matches, Acc) ->
	case random:uniform() < Prob of
	true ->
		more_matches(Matches, [Spec|Acc]);
	_ ->
		more_matches(Matches, Acc)
	end.

bit_len(eth_dst) -> 48;
bit_len(ip_dscp) -> 6;
bit_len(vlan_vid) -> 13.

%%EOF
