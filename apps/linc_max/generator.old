#!/usr/bin/env escript
%%
%%

-define(VLAN_VID_NONE,		16#0000).
-define(VLAN_VID_PRESENT,	16#1000).

%main([Value,Mask]) ->
%	V = list_to_integer(Value, 16),
%	M = list_to_integer(Mask, 16),
%	lists:map(fun(X) ->
%		S = sub_mask(X),
%		io:format("~.16b\n~.16b\n\n", [S,V band S])
%	end, split_mask(M));

main([TabFile]) ->
	{ok,FlowEnts} = file:consult(TabFile),
	F = {function,[],tcp,8,flow_ents(FlowEnts)},
	io:format("~s", [erl_pp:form(F)]).

flow_ents(FlowEnts) ->
	[{clause,[],matches(Specs),
				[],
				[{atom,[],Action}]}
			|| {Action,Specs} <- FlowEnts]
		++
	[{clause,[],miss_matches(),
				[],
				[{atom,[],miss}]}].

matches(Specs) ->
	Ms = [spec(Spec) || Spec <- Specs],
	Args = lists:usort([Arg || {Arg,_} <- Ms]),
	Fs = [{Arg,flatten([Xs || {Arg1,Xs} <- Ms, Arg1 =:= Arg])}
			|| Arg <- Args],
	lists:map(fun(A) ->
		case lists:keyfind(A, 1, Fs) of
		false ->
			{var,[],'_'};
		{_,[N]} when is_integer(N) ->
			{integer,[],N};
		{_,Zs} ->
			{bin,[],bin_elems(Zs)}
		end
	end, arguments()).

miss_matches() ->
	[{var,[],'_'} || _ <- arguments()].

arguments() ->
	[packet,
	 vlan_tag,
	 eth_type,
	 pbb_tag,
	 mplstag,
	 ip4_hdr,
	 ip6_hdr,
	 ip6_ext].

%{bin,4,
% [{bin_element,4,{var,4,'_Dst'},default,default},
%  {bin_element,4,{integer,4,0},default,default},
%  {bin_element,4,{integer,4,1},default,default},
%  {bin_element,4,{integer,4,2},default,default},
%  {bin_element,4,{integer,4,3},default,default},
%  {bin_element,4,{integer,4,4},default,default},
%  {bin_element,4,{integer,4,5},default,default},
%  {bin_element,4,{var,4,'_'},default,[binary]}

spec({in_port,_Value}) ->
	[]; %%TODO
spec({in_phy_port,_Value}) ->
	[]; %%TODO
spec({metadata,_Value,_Mask}) ->
	[]; %%TODO
spec({eth_dst,Value,Mask}) ->
	match(packet, 0, 48, Value, Mask);
spec({eth_src,Value,Mask}) ->
	match(packet, 48, 48, Value, Mask);
spec({eth_type,Value}) ->
	{eth_type,[Value]};
spec({vlan_vid,?VLAN_VID_NONE,nomask}) ->
	[]; %%TODO
spec({vlan_vid,?VLAN_VID_PRESENT,?VLAN_VID_PRESENT}) ->
	[]; %%TODO
spec({vlan_vid,Value,nomask}) ->
	match(vlan_tag, 4, 12, Value, nomask);
spec({vlan_pcp,Value}) ->
	match(vlan_tag, 0, 3, Value, nomask);
spec({ip_dscp,_Value}) ->
	[]; %%TODO match EthType = 0x800 and Ip4Hdr or EthType = 0x86dd and Ip6Hdr
spec({ip_ecn,_Value}) ->
	[]; %%TODO match EthType = 0x800 and Ip4Hdr or EthType = 0x86dd and Ip6Hdr
spec({ip_proto,_Value}) ->
	[]; %%TODO match EthType = 0x800 and Ip4Hdr or EthType = 0x86dd and Ip6Hdr
spec({ipv4_src,Value,Mask}) ->
	match(ip4_hdr, 96, 32, Value, Mask);
spec({ipv4_dst,Value,Mask}) ->
	match(ip4_hdr, 128, 32, Value, Mask);
spec({tcp_src,Value}) ->
	match(tcphdr, 0, 16, Value, nomask);
spec({tcp_dst,Value}) ->
	match(tcphdr, 16, 16, Value, nomask);
spec({udp_src,Value}) ->
	match(udphdr, 0, 16, Value, nomask);
spec({udp_dst,Value}) ->
	match(udphdr, 16, 16, Value, nomask);
spec({sctp_src,Value}) ->
	match(sctphdr, 0, 16, Value, nomask);
spec({sctp_dst,Value}) ->
	match(sctphdr, 16, 16, Value, nomask);
spec({icmpv4_type,Value}) ->
	match(icmphdr, 0, 8, Value, nomask);
spec({icmpv4_code,Value}) ->
	match(icmphdr, 8, 8, Value, nomask);
spec({arp_op,Value}) ->
	match(arpmsg, 48, 16, Value, nomask);
spec({arp_spa,Value,Mask}) ->
	match(arpmsg, 112, 32, Value, Mask);
spec({arp_tpa,Value,Mask}) ->
	match(arpmsg, 192, 32, Value, Mask);
spec({arp_sha,Value,Mask}) ->
	match(arpmsg, 48, 48, Value, Mask);
spec({arp_tha,Value,Mask}) ->
	match(arpmsg, 144, 48, Value, Mask);
spec({ipv6_src,Value,Mask}) ->
	match(ip6_hdr, 64, 128, Value, Mask);
spec({ipv6_dst,Value,Mask}) ->
	match(ip6_hdr, 192, 128, Value, Mask);
spec({ipv6_flabel,Value,Mask}) ->
	match(ip6_hdr, 12, 20, Value, Mask);
spec({icmpv6_type,Value}) ->
	match(icmp6hdr, 0, 8, Value, nomask);
spec({icmpv6_code,Value}) ->
	match(icmp6hdr, 8, 8, Value, nomask);
spec({ipv6_nd_target,_Value}) ->
	[]; %%TODO use guard that nd_sll or nd_tll is not 'none'
spec({ipv6_nd_sll,_Value}) ->
	[]; %%TODO
spec({ipv6_nd_tll,_Value}) ->
	[]; %%TODO
spec({mpls_label,Value}) ->
	match(mplstag, 0, 20, Value, nomask);
spec({mpls_tc,Value}) ->
	match(mplstag, 20, 3, Value, nomask);
spec({mpls_bos,Value}) ->
	match(mplstag, 23, 1, Value, nomask);
spec({pbb_isid,Value,Mask}) ->
	match(pbb_tag, 8, 24, Value, Mask);
spec({tunnel_id,_Value,_Mask}) ->
	[]; %%TODO
spec({ipv6_exthdr,Value,Mask}) ->
	match(ip6_ext, 0, 9, Value, Mask);
spec({pbb_uca,Value}) ->
	match(pbb_tag, 4, 1, Value, nomask).

match(Arg, Start, Bits, Value, nomask) ->
	{Arg,[{Start,Bits,Value}]};
match(Arg, Start, Bits, Value, Mask) ->
	{Arg,[{Start +Bits -Pos -Len,
		   Len,
		   (Value band sub_mask(Pos, Len)) bsr Pos}
				|| {Pos,Len} <- split_mask(Mask)]}.

split_mask(Mask) ->
	split_mask(Mask, 0, 1, 0, []).

split_mask(0, _, _, 0, Acc) ->
	Acc;
split_mask(0, N, _, Ones, Acc) ->
	[{N -Ones,Ones}|Acc];
split_mask(Mask, N, Probe, Ones, Acc) when Mask band Probe =/= 0 ->
	split_mask(Mask band (bnot Probe), N +1, Probe bsl 1, Ones +1, Acc);
split_mask(Mask, N, Probe, 0, Acc) ->
	split_mask(Mask, N +1, Probe bsl 1, 0, Acc);
split_mask(Mask, N, Probe, Ones, Acc) ->
	split_mask(Mask, N +1, Probe bsl 1, 0, [{N -Ones,Ones}|Acc]).

%sub_mask({N,L}) ->
%	sub_mask(N, L).

sub_mask(N, L) ->
	((1 bsl L) -1) bsl N.

flatten(Ss) ->
	flatten1(lists:keysort(1, lists:concat(Ss))).

flatten1(Ts) ->
	flatten1(Ts, []).

flatten1([T], Acc) ->
	lists:reverse([T|Acc]);
flatten1([nomatch|_], _Acc) ->
	nomatch;
flatten1([Val,[Val|_] =Ts], Acc) when is_integer(Val) ->
	flatten1(Ts, Acc);
flatten1([Val1,[Val2|_] =Ts], Acc) when is_integer(Val1), is_integer(Val2) ->
	nomatch;
flatten1([{Start1,Len1,_Val1} =T|[{Start2,_Len2,_Val2}|_] =Ts], Acc)
		when Start1 +Len1 < Start2 ->
	flatten1(Ts, [T|Acc]);
flatten1([T1,T2|Ts], Acc) ->
	%io:format("combine ~p and ~p~n", [T1,T2]),
	flatten1([combine1(T1, T2)|Ts], Acc).

combine1({S1,L1,V1} =T1, {S2,L2,_V2} =T2) ->
	IS = S2,
	X = S1 +L1 -S2,
	IL = if X < L2 -> X; true -> L2 end,
	IV1 = cut1(T1, IS, IL),
	IV2 = cut1(T2, IS, IL),
	TS = S1 +L1,
	TL = S2 +L2 -TS,
	if IV1 =/= IV2 ->
		nomatch;
	TL =< 0 ->
		T1;
	true ->
		{S1,
		 L1 +TL,
		 (V1 bsl TL) bor cut1(T2, TS, TL)}
	end.

cut1({S,L,V}, SA, LA) ->
	X = S +L -SA -LA,
	(V bsr X) band ((1 bsl LA) -1).

bin_elems(Zs) ->
	bin_elems(0, Zs, []).

bin_elems(O, [], Acc) when O rem 8 =:= 0 ->
	E = {bin_element,[],{var,[],'_'},default,[binary]},
	lists:reverse([E|Acc]);
bin_elems(_O, [], Acc) ->
	E = {bin_element,[],{var,[],'_'},default,[bits]},
	lists:reverse([E|Acc]);
bin_elems(O, [{S,_,_}|_] =Zs, Acc) when S > O ->
	E = {bin_element,[],{var,[],'_'},{integer,[],S -O},[bits]},
	bin_elems(S, Zs, [E|Acc]);
bin_elems(S, [{S,L,V}|Zs], Acc) ->
	E = {bin_element,[],{integer,[],V},{integer,[],L},default},
	bin_elems(S +L, Zs, [E|Acc]).

%print_match({Arg,nomatch}) ->
%	io:format("Arg~w never match\n", [Arg]);
%print_match({Arg,Zs}) ->
%	io:format("Arg[~w]:\n", [Arg]),
%	lists:foreach(fun({Start,Len,Value}) ->
%		io:format("\t[~w:~w] equals 0x~.16b\n", [Start,Start+Len-1,Value])
%	end, Zs).

%%EOF
